# ==========================================================
# YBFuzz Framework Configuration
# ==========================================================

# --- Run Control ---
duration: 300                  # Fuzzing duration in seconds
max_sessions: 500              # Maximum number of sessions to generate
random_seed: null              # Set to an integer for reproducible runs, or null for random
log_level: INFO                # DEBUG, INFO, WARNING, ERROR
log_file: "ybfuzz_run.log"       # Main log file
bug_report_file: "bugs.log"    # File for detailed, structured bug reports
sql_log_file: "executed_queries.sql" # A clean script for easy reproduction
catalog_refresh_interval: 5    # How often (in sessions) to refresh the DB schema

# --- Database Connection ---
database:
  host: "10.9.86.186,10.9.139.177,10.9.205.248"
  port: 5433
  user: "yugabyte"
  password: "Password#123"
  dbname: "yugabyte"
  schema_name: "ybfuzz_schema"

# --- Sanitizer Configuration ---
# Configure this section when running against a sanitizer-enabled build of YugabyteDB.
sanitizer:
  # The type of sanitizer being used. E.g., "ASan", "TSan", "UBSan".
  # This will be included in bug reports for better classification.
  type: "ASan"
  # The absolute path to the database log file where sanitizer output can be found.
  # The bug reporter will scan this file when a crash is detected.
  log_file_path: "/path/to/yugabytedb/logs/tserver.INFO" # IMPORTANT: Update this path

# --- Initial Database State ---
# SQL commands to run at the start of each fuzzing session.
# Use '$$schema$$' as a placeholder for the schema_name above.
initial_db_setup_sqls:
  - "CREATE TABLE $$schema$$.products (id INT PRIMARY KEY, name TEXT, category TEXT, price NUMERIC, stock_count INT);"
  - "INSERT INTO $$schema$$.products SELECT g, 'Product-' || g, 'Category-' || (g%10), g*1.5, g*10 FROM generate_series(1,100) g;"
  - "CREATE TABLE $$schema$$.orders (id SERIAL PRIMARY KEY, order_id INTEGER, product_id INTEGER, quantity INTEGER, price NUMERIC(10,2), order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP);"
  - "INSERT INTO $$schema$$.orders (order_id, product_id, quantity, price) SELECT g, (g % 50) + 1, (g % 10) + 1, (g % 100) + 10.0 FROM generate_series(1,50) g;"
  - "CREATE TABLE $$schema$$.customers (id SERIAL PRIMARY KEY, name TEXT, email TEXT, phone TEXT, address TEXT, created_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP);"
  - "INSERT INTO $$schema$$.customers (name, email, phone, address) SELECT 'Customer-' || g, 'customer' || g || '@example.com', '+1-555-' || LPAD(g::text, 4, '0'), 'Address ' || g || ', City, State' FROM generate_series(1,25) g;"
  - "CREATE TABLE $$schema$$.categories (id SERIAL PRIMARY KEY, name TEXT, description TEXT, parent_id INTEGER);"
  - "INSERT INTO $$schema$$.categories (name, description, parent_id) SELECT 'Category-' || g, 'Description for category ' || g, CASE WHEN g % 3 = 0 THEN NULL ELSE (g % 5) + 1 END FROM generate_series(1,10) g;"

# --- Fuzzer Engine Strategy ---
engine_strategy:
  # Probability (0.0 to 1.0) of using the mutational engine.
  mutation_probability: 0.7

# --- Corpus Configuration ---
corpus:
  seed_file: "corpus/seed_queries.txt"

# --- Corpus Evolution Strategy ---
# Allows the fuzzer to learn and save "interesting" queries.
corpus_evolution:
  enabled: true
  directory: "evolved_corpus" # Discovered queries will be saved here

# --- Test Case Reducer Configuration ---
reducer:
  enabled: true

# --- SQLLogicTest Formatter Configuration ---
# Automatically generates a .test file for each unique bug found.
sqllogictest_formatter:
  enabled: true
  output_directory: "sqllogic_tests"

# --- Grammar File for Generative Engine ---
grammar_file: "core/grammar.yaml"

# --- Grammar and Generator Control ---
max_recursion_depth:
  expression: 5

# Weights for choosing which statement to generate within a phase
statement_weights:
  ddl_statement:
    create_table_stmt: 50
    create_view_stmt: 30
    create_index_stmt: 20
  dml_statement:
    insert_stmt: 50
    update_stmt: 40
    delete_stmt: 10
  select_stmt: 100

# When a rule is a "choice" (A | B | C), these weights guide the selection.
rule_choice_weights:
  select_list_item:
    column_name: 0.5
    aggregate_function: 0.4
    scalar_function: 0.1

# Probabilities (0.0 to 1.0) for expanding optional or repeatable grammar rules.
rule_expansion_probabilities:
  select_stmt:
    WHERE: 0.9
    GROUP_BY: 0.7
    LIMIT: 0.4
  boolean_term:
    AND: 0.5

# --- Stateful Session Strategy ---
session_strategy:
  ddl_statements: [1, 2]
  dml_statements: [3, 8]
  final_select_statements: 1

# --- Mutator Strategy Control ---
mutator_strategies:
  mutate_literal:
    enabled: true
    weight: 1.0
  mutate_comparison_operator:
    enabled: true
    weight: 0.8
  mutate_function_name:
    enabled: true
    weight: 0.5

# --- Oracle Configuration ---
oracles:
  TLOracle:
    enabled: true
    enable_norec: true
    enable_tlp: true
    norec_settings:
      - "enable_nestloop"
      - "enable_hashjoin"
  
  QPGOracle:
    enabled: true
    enable_cert: true
    enable_dqp: true
    enable_coddtest: true
    cert_threshold: 100 # Report bug if estimate is off by 100x
    
    # Smart filtering to reduce false positives
    enable_smart_filtering: true
    filter_type_casting: true      # Filter out type casting changes
    filter_storage_filters: true   # Filter out storage filter changes
    min_significant_changes: 3    # Minimum structural changes to report as bug
