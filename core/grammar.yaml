# ===================================================================
# YBFuzz SQL Grammar Definition
# ===================================================================
# This file defines the SQL grammar used by the generative fuzzer.
# It is designed to be human-readable and easily extensible.

# --- Top Level Statement Types ---
# The engine now asks for a specific type of statement (DDL, DML, or SELECT)
statement:
  type: choice
  options: [ddl_statement, dml_statement, select_stmt]

ddl_statement:
  type: choice
  options: [create_table_stmt, create_view_stmt, create_index_stmt]

dml_statement:
  type: choice
  options: [insert_stmt, update_stmt, delete_stmt]

# --- DDL Statements ---
create_table_stmt:
  type: sequence
  elements:
    - { rule: "CREATE TABLE", type: keyword }
    - { rule: new_table_name, type: non_terminal }
    - { rule: "(", type: keyword }
    - { rule: column_definitions, type: non_terminal }
    - { rule: ")", type: keyword }

create_view_stmt:
  type: sequence
  elements:
    - { rule: "CREATE VIEW", type: keyword }
    - { rule: new_view_name, type: non_terminal }
    - { rule: "AS", type: keyword }
    - { rule: select_stmt, type: non_terminal }

create_index_stmt:
  type: sequence
  elements:
    - { rule: "CREATE INDEX", type: keyword }
    - { rule: new_index_name, type: non_terminal }
    - { rule: "ON", type: keyword }
    - { rule: table_name, type: non_terminal }
    - { rule: "(", type: keyword }
    - { rule: column_name, type: non_terminal }
    - { rule: ")", type: keyword }

column_definitions:
  type: sequence
  elements:
    - { rule: column_definition, type: non_terminal, repeatable: true, separator: ", " }

column_definition:
  type: sequence
  elements:
    - { rule: column_name, type: non_terminal }
    - { rule: data_type, type: non_terminal }

# --- DML Statements ---
insert_stmt:
  type: sequence
  elements:
    - { rule: "INSERT INTO", type: keyword }
    - { rule: table_name, type: non_terminal }
    - { rule: "(", type: keyword }
    - { rule: column_list, type: non_terminal }
    - { rule: ")", type: keyword }
    - { rule: "VALUES", type: keyword }
    - { rule: "(", type: keyword }
    - { rule: literal_list, type: non_terminal }
    - { rule: ")", type: keyword }

update_stmt:
  type: sequence
  elements:
    - { rule: "UPDATE", type: keyword }
    - { rule: table_name, type: non_terminal }
    - { rule: "SET", type: keyword }
    - { rule: update_assignment, type: non_terminal }
    - { rule: where_clause, type: non_terminal, optional: true, config_key: "WHERE" }

delete_stmt:
  type: sequence
  elements:
    - { rule: "DELETE FROM", type: keyword }
    - { rule: table_name, type: non_terminal }
    - { rule: where_clause, type: non_terminal, optional: true, config_key: "WHERE" }

column_list:
  type: sequence
  elements:
    - { rule: column_name, type: non_terminal, repeatable: true, separator: ", " }

literal_list:
  type: sequence
  elements:
    - { rule: literal, type: non_terminal, repeatable: true, separator: ", " }

update_assignment:
  type: sequence
  elements:
    - { rule: column_name, type: non_terminal }
    - { rule: "=", type: keyword }
    - { rule: update_expression, type: non_terminal }

# --- UPDATE-specific Expression (no comparison operators) ---
update_expression:
  type: choice
  options: [arithmetic_expression, literal, column_name]

# --- SELECT Statement Breakdown ---
select_stmt:
  type: sequence
  elements:
    - { rule: "SELECT", type: keyword }
    - { rule: select_list, type: non_terminal }
    - { rule: from_clause, type: non_terminal }
    - { rule: where_clause, type: non_terminal, optional: true, config_key: "WHERE" }
    - { rule: group_by_clause, type: non_terminal, optional: true, config_key: "GROUP_BY" }
    - { rule: limit_clause, type: non_terminal, optional: true, config_key: "LIMIT" }

select_list:
  type: sequence
  elements:
    - { rule: select_list_item, type: non_terminal, repeatable: true, separator: ", " }

select_list_item:
  type: choice
  options: [column_name, aggregate_function]

aggregate_function:
  type: sequence
  elements:
    - { rule: aggregate_op, type: non_terminal }
    - { rule: "(", type: keyword }
    - { rule: aggregate_argument, type: non_terminal }
    - { rule: ")", type: keyword }

aggregate_argument:
  type: choice
  options: [column_name, "*"]

aggregate_op:
  type: choice
  options: ["SUM", "AVG", "MIN", "MAX", "COUNT"]

from_clause:
  type: sequence
  elements:
    - { rule: "FROM", type: keyword }
    - { rule: table_name, type: non_terminal }

where_clause:
  type: sequence
  elements:
    - { rule: "WHERE", type: keyword }
    - { rule: expression, type: non_terminal }

group_by_clause:
  type: sequence
  elements:
    - { rule: "GROUP BY", type: keyword }
    - { rule: group_by_list, type: non_terminal }

group_by_list:
  type: sequence
  elements:
    - { rule: column_name, type: non_terminal, repeatable: true, separator: ", " }

limit_clause:
  type: sequence
  elements:
    - { rule: "LIMIT", type: keyword }
    - { rule: integer_literal, type: non_terminal }

# --- Expressions (Highly Recursive) ---
expression:
  type: choice
  options: [boolean_expression, arithmetic_expression, literal]

arithmetic_expression:
  type: sequence
  elements:
    - { rule: arithmetic_term, type: non_terminal }
    - { rule: arithmetic_expression_suffix, type: non_terminal, optional: true, config_key: "PLUS_MINUS" }

arithmetic_expression_suffix:
  type: sequence
  elements:
    - { rule: arithmetic_operator, type: non_terminal }
    - { rule: arithmetic_term, type: non_terminal }

arithmetic_term:
  type: sequence
  elements:
    - { rule: arithmetic_factor, type: non_terminal }
    - { rule: arithmetic_term_suffix, type: non_terminal, optional: true, config_key: "MULT_DIV" }

arithmetic_term_suffix:
  type: sequence
  elements:
    - { rule: arithmetic_operator, type: non_terminal }
    - { rule: arithmetic_factor, type: non_terminal }

arithmetic_factor:
  type: choice
  options: [column_name, literal]

arithmetic_operator:
  type: choice
  options: ["+", "-", "*", "/"]

boolean_expression:
  type: sequence
  elements:
    - { rule: boolean_term, type: non_terminal }
    - { rule: boolean_expression_suffix, type: non_terminal, optional: true, config_key: "OR" }

boolean_expression_suffix:
  type: sequence
  elements:
    - { rule: "OR", type: keyword }
    - { rule: boolean_term, type: non_terminal }

boolean_term:
  type: sequence
  elements:
    - { rule: boolean_factor, type: non_terminal }
    - { rule: boolean_term_suffix, type: non_terminal, optional: true, config_key: "AND" }

boolean_term_suffix:
  type: sequence
  elements:
    - { rule: "AND", type: keyword }
    - { rule: boolean_factor, type: non_terminal }

boolean_factor:
  type: choice
  options: [comparison_predicate]

comparison_predicate:
  type: sequence
  elements:
    - { rule: column_name, type: non_terminal }
    - { rule: comparison_op, type: non_terminal }
    - { rule: literal, type: non_terminal }

comparison_op:
  type: choice
  options: ["=", "<>", "<", "<=", ">", ">="]

# --- Terminals / Placeholders ---
new_table_name: { type: terminal }
new_view_name: { type: terminal }
new_index_name: { type: terminal }
table_name: { type: terminal }
column_name: { type: terminal }
data_type: { type: terminal }
literal: { type: terminal }
integer_literal: { type: terminal }
scalar_function: { type: terminal }
function_call: { type: terminal }
comparison_op: { type: terminal }
aggregate_op: { type: terminal }